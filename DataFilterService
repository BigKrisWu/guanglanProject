
import com.huawei.fiber.entity.ConditionModel;
import com.huawei.fiber.entity.FilterModel;
import com.huawei.fiber.entity.RuleModel;
import com.huawei.fiber.utils.ServiceUtil;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVPrinter;
import org.apache.commons.csv.CSVRecord;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

/**
 * @since 2024/5/24
 */
@Component
public class DataFilterService {
    private static final Logger LOGGER = LoggerFactory.getLogger(DataFilterService2.class);
    private static final String SRC_TMP_DIR = "/opt/collection/srcTemp/";

    public void filterData() throws IOException {
        List<RuleModel> ruleModels = ServiceUtil.getC2DataRules();
        ruleModels.sort(Comparator.comparingInt(RuleModel::getNum));

        String baselineResultFile = null;
        for (RuleModel ruleModel : ruleModels) {
            String primaryTable = ruleModel.getPrimaryTable();
            String combinedTable = ruleModel.getCombinedTable();

            if (ruleModel.getNum() == 1) {
                String baselineFile = SRC_TMP_DIR + getOriginalFile(primaryTable);
                baselineResultFile = filterBaselineData(baselineFile, ruleModel.getBaseFilters(), primaryTable);
                deleteMatchingFiles(ruleModel);
            } else {
                String combinedFile = SRC_TMP_DIR + getOriginalFile(combinedTable);
                String resultFile = filterCombinedData(baselineResultFile, combinedFile, ruleModel.getCombinedFilters(), ruleModel.getRelationFilters(), combinedTable);
                deleteMatchingFiles(ruleModel);

                if (combinedTable != null && !combinedTable.isEmpty()) {
                    baselineResultFile = resultFile;
                }
            }
        }
    }

    private String getOriginalFile(String fileName) throws IOException {
        try (Stream<Path> paths = Files.walk(Paths.get(SRC_TMP_DIR))) {
            Optional<Path> matchingFile = paths.filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().contains(fileName))
                    .findFirst();

            return matchingFile.map(Path::getFileName).map(Path::toString).orElse(null);
        }
    }

    private String filterBaselineData(String baselineFile, List<FilterModel> baseFilters, String resultFileName) {
        List<String[]> filteredData = new ArrayList<>();
        List<String> headers = new ArrayList<>();
        try (Reader reader = new FileReader(baselineFile);
            CSVParser parser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())) {
            headers = parser.getHeaderNames();

            for (CSVRecord record : parser) {
                boolean match = baseFilters.stream().allMatch(filter -> {
                    String value = record.get(filter.getFilterField());
                    return evaluateCondition(value, filter.getOperator(), filter.getFilterValue());
                });

                if (match) {
                    String[] filteredRow = new String[headers.size()];
                    for (int i = 0; i < headers.size(); i++) {
                        filteredRow[i] = record.get(i);
                    }
                    filteredData.add(filteredRow);
                }
            }
        } catch (IOException e) {
            LOGGER.error("过滤基线数据时发生错误: {}", baselineFile, e);
        }

        String resultFilePath = SRC_TMP_DIR + resultFileName + ".csv";
        writeCSV(resultFilePath, filteredData, headers.toArray(new String[0]));
        return resultFilePath;
    }



    private String filterCombinedData(String baselineResultFile, String combinedFile, List<FilterModel> combinedFilters, List<ConditionModel> relationFilters, String resultFileName) {
        List<CSVRecord> baselineData = readCSV(baselineResultFile);
        List<String> baselineHeaders = new ArrayList<>(baselineData.get(0).toMap().keySet());

        List<String[]> filteredData = new ArrayList<>();

        try (Reader reader = new FileReader(combinedFile);
            CSVParser parser = new CSVParser(reader,
                CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())) {
            List<String> combinedHeaders = parser.getHeaderNames();

            for (CSVRecord record : parser) {
                if (record.isSet(relationFilters.get(0).getCombinedField()) && record.isSet(relationFilters.get(1).getCombinedField()) && record.isSet(combinedFilters.get(0).getFilterField())) {
                    boolean combinedMatch = evaluateFilters(record, combinedFilters);
                    boolean relationMatch = false;

                    if (!combinedMatch) {
                        relationMatch = evaluateRelationFilters(record, combinedHeaders, baselineData, baselineHeaders, relationFilters);
                    }

                    if (combinedMatch || relationMatch) {
                        String[] filteredRow = new String[combinedHeaders.size()];
                        for (int j = 0; j < combinedHeaders.size(); j++) {
                            filteredRow[j] = record.get(j);
                        }
                        filteredData.add(filteredRow);
                    }
                }
            }
        } catch (IOException e) {
            LOGGER.error("过滤组合数据时发生错误: {}", combinedFile, e);
        }

        String resultFilePath = SRC_TMP_DIR + resultFileName + ".csv";
        writeCSV(resultFilePath, filteredData, baselineHeaders.toArray(new String[0]));
        return resultFilePath;
    }


    private boolean evaluateFilters(CSVRecord record, List<FilterModel> filters) {
        for (FilterModel filter : filters) {
            String value = record.get(filter.getFilterField());
            boolean conditionResult = evaluateCondition(value, filter.getOperator(), filter.getFilterValue());
            if (!conditionResult) {
                return false;
            }
        }
        return true;
    }

    private boolean evaluateRelationFilters(CSVRecord combinedRecord, List<String> combinedHeaders, List<CSVRecord> baselineData, List<String> baselineHeaders, List<ConditionModel> relationFilters) {
        for (ConditionModel relationFilter : relationFilters) {
            int combinedIndex = combinedHeaders.indexOf(relationFilter.getCombinedField());
            int baselineIndex = baselineHeaders.indexOf(relationFilter.getBaseField());

            if (combinedIndex >= 0 && baselineIndex >= 0) {
                boolean matchFound = false;
                String combinedValue = combinedRecord.get(combinedIndex);

                for (CSVRecord baselineRecord : baselineData) {
                    String baselineValue = baselineRecord.get(baselineIndex);
                    matchFound = evaluateCondition(baselineValue, relationFilter.getOperator(), combinedValue);
                    if (matchFound) {
                        break;
                    }
                }

                if (!matchFound) {
                    return false;
                }
            }
        }
        return true;
    }

    private boolean evaluateCondition(String value, String operator, String filterValue) {
        switch (operator) {
            case "=":
                return filterValue.equals(value);
            case "!=":
                return !filterValue.equals(value);
            case "contains":
                return value.contains(filterValue);
            case "is empty":
                return value.isEmpty();
            case "is not empty":
                return !value.isEmpty();
            default:
                return false;
        }
    }

    private void deleteMatchingFiles(RuleModel ruleModel) throws IOException {
        String tableName = StringUtils.isNotBlank(ruleModel.getCombinedTable()) ? ruleModel.getCombinedTable() : ruleModel.getPrimaryTable();
        try (Stream<Path> paths = Files.walk(Paths.get(SRC_TMP_DIR))) {
            paths.filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().contains(tableName))
                    .filter(path -> !path.getFileName().toString().startsWith(tableName))
                    .forEach(path -> {
                        File file = path.toFile();
                        if (file.delete()) {
                            LOGGER.warn("Deleted file: {}", file.getAbsolutePath());
                        } else {
                            LOGGER.warn("Failed to delete file: {}", file.getAbsolutePath());
                        }
                    });
        }
    }

    private List<CSVRecord> readCSV(String filePath) {
        List<CSVRecord> data = new ArrayList<>();
        try (Reader reader = new FileReader(filePath);
            CSVParser parser = new CSVParser(reader, CSVFormat.DEFAULT.withFirstRecordAsHeader().withIgnoreHeaderCase().withTrim())) {
            for (CSVRecord record : parser) {
                data.add(record);
            }
        } catch (IOException e) {
            LOGGER.error("Error occurred while reading CSV file: {}", filePath, e.getMessage());
        }
        return data;
    }

    private void writeCSV(String filePath, List<String[]> data, String[] headers) {
        try (CSVPrinter printer = new CSVPrinter(new FileWriter(filePath), CSVFormat.DEFAULT.withHeader(headers))) {
            for (String[] row : data) {
                printer.printRecord((Object[]) row);
            }
        } catch (IOException e) {
            LOGGER.error("Error occurred while writing CSV file: {}", filePath, e.getMessage());
        }
    }
}
