import com.huawei.baize.security.misc.io.FileSecUtils;
import com.huawei.fiber.constant.CodeStatus;
import com.huawei.fiber.constant.Constants;
import com.huawei.fiber.service.FileSynchronizationService;
import com.huawei.fiber.utils.ServiceUtil;
import com.huawei.fiber.utils.SftpClientUtil;
import com.huawei.ows.sdk.base.common.context.ContextManager;
import com.huawei.ows.sdk.base.crypto.CryptoUtils;
import com.huawei.us.common.file.UsFileUtils;
import com.alibaba.fastjson.JSONObject;
import org.apache.sshd.client.channel.ChannelExec;
import org.apache.sshd.client.channel.ClientChannelEvent;
import org.apache.sshd.sftp.client.SftpClient;
import org.apache.sshd.sftp.common.SftpConstants;
import org.apache.sshd.sftp.common.SftpException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * 同步文件上传下载
 *
 * @since 2024/5/2
 */
@Component
public class FileSynchronizationServiceImpl implements FileSynchronizationService {
    private static final Logger LOGGER = LoggerFactory.getLogger(FileSynchronizationServiceImpl.class);

    private static String remoteIp;

    private static String remoteDir;

    private static int port;

    private static String username;

    private static String password;

    private static Set<String> fileSet;

    private static String filesDirectory;

    private static int maxDirSize;

    private static String sftp_host;

    private static int sftp_port;

    private static String sftp_username;

    private static String sftp_password;

    private static String sftp_remoteDir;

    public static final String LOCALTEMPDIR = "/opt/collection/srcTemp";

    public static final Pattern DIR_PATTERN = Pattern.compile("\\d{8}");
    public static final Pattern CONTINUATIVE_NUM_PATTERN = Pattern.compile("(\\d{14})"); // 匹配连续的14位数字

    public static Map<String, String> map = new HashMap<>(3);

    private static final List<String> processList = Arrays.asList("_SEGMENT_", "_STRONGHOLD_", "_CABLELAYING_",
            "_CIRCUITASSIGN_", "_CIRCUITLINK_", "_FIBER_", "_JOINT_", "_LOGICALFIBERCIR_", "_OCCP_", "_OPTCABLESECTION_",
            "_OPTICALCABLE_", "_OPTICALCIRCUIT_", "_IRM_IV_OTN_");

    public static void fetchConfigFromPage() {
        Map<String, String> parameter = ServiceUtil.getNebulaConfig();
        remoteIp = parameter.get("remote_ip");
        remoteDir = parameter.get("remote_dir");
        port = Integer.parseInt(parameter.get("port"));
        username = parameter.get("username");
        password = CryptoUtils.decrypt(parameter.get("password"), ContextManager.getCurrentTenantId());
        fileSet = new HashSet<>(Arrays.asList(parameter.get("file_set").split(",")));
        filesDirectory = parameter.get("files_directory");
        maxDirSize = Integer.parseInt(parameter.get("max_dir_size"));
        sftp_host = parameter.get("sftp_host");
        sftp_port = Integer.parseInt(parameter.get("sftp_port"));
        sftp_username = parameter.get("sftp_username");
        sftp_password = CryptoUtils.decrypt(parameter.get("sftp_password"), ContextManager.getCurrentTenantId());
        sftp_remoteDir = parameter.get("sftp_remote_dir");
        map.put("src", sftp_remoteDir + File.separator + "src");
        map.put("col", sftp_remoteDir + File.separator + "col");
        map.put("pro", sftp_remoteDir + File.separator + "pro");
    }

    @Override
    public boolean synchronizeFiles() throws IOException {
        checkAndCreateDirectory(LOCALTEMPDIR);
        SftpClient srcSftpClient = createSftpClient(remoteIp, username, password, port);
        List<String> recentDirs = getRecentDirs(srcSftpClient, remoteDir, maxDirSize);
        return handleFileSync(recentDirs, map.get("src"), map.get("pro"));
    }

    @Override
    public JSONObject uploadResultFiles(String localDirectoryPath, String remoteDirectoryPath) throws IOException {
        JSONObject result = new JSONObject();
        SftpClient sftpClient = createSftpClient(sftp_host, sftp_username, sftp_password, sftp_port);
        ensureDirectoryExists(sftpClient, remoteDirectoryPath);

        try (Stream<Path> paths = Files.walk(FileSecUtils.getPath(localDirectoryPath))) {
            // 后续需整改，不能写死
            List<Path> filesToUpload = paths.filter(Files::isRegularFile)
                    .filter(path -> path.getFileName().toString().startsWith("D_"))
                    .collect(Collectors.toList());

            // 上传每个文件到远程目录
            for (Path file : filesToUpload) {
                String localFilePath = file.toString();
                String remoteFilePath = remoteDirectoryPath + File.separator + file.getFileName().toString();
                uploadFile(sftpClient, localFilePath, remoteFilePath);
            }
            clearLocalTempDir();
            result.put(CodeStatus.SUCCESS.getValue(), "The task is executed successfully.");
        } catch (IOException e) {
            result.put(CodeStatus.FAILED.getValue(), "The task is executed failed.");
            LOGGER.error("[OCDCollectionService][uploadResultFiles]Error uploading files: {}", e.getMessage());
        } finally {
            sftpClient.close();
        }
        return result;
    }

    private List<String> getRecentDirs(SftpClient sftp, String remoteDir, int maxDirSize) throws IOException {
        Iterable<SftpClient.DirEntry> dirEntries = sftp.readDir(remoteDir);
        List<String> recentDirs = new ArrayList<>();
        for (SftpClient.DirEntry entry : dirEntries) {
            if (entry.getAttributes().isDirectory()) {
                String dirName = entry.getFilename();
                if (DIR_PATTERN.matcher(dirName).matches()) {
                    try {
                        sftp.stat(remoteDir + File.separator + dirName + File.separator + filesDirectory);
                        recentDirs.add(dirName);
                    } catch (SftpException e) {
                        LOGGER.error("[OCDCollectionService][getRecentDirs]Skipping directory as 'files' subdirectory does not exist: " + dirName);
                    }
                }
            }
        }
        recentDirs.sort(Collections.reverseOrder());
        return recentDirs.subList(0, Math.min(recentDirs.size(), maxDirSize));
    }

    private Set<String> retrieveSrcFiles(SftpClient sftp, List<String> recentDirs) throws IOException {
        Set<String> matchedFiles = new HashSet<>();
        for (String dir : recentDirs) {
            Iterable<SftpClient.DirEntry> files = sftp.readDir(
                    remoteDir + File.separator + dir + File.separator + filesDirectory);
            for (SftpClient.DirEntry entry : files) {
                String filename = entry.getFilename();
                for (String pattern : fileSet) {
                    if (filename.contains(pattern)) {
                        String filePath = remoteDir + File.separator + dir + File.separator + filesDirectory
                                + File.separator + filename;
                        SftpClient.Attributes attrs = sftp.stat(filePath);
                        if (attrs.getSize() > 0) {
                            if (hasDataLines(sftp, filePath)) {
                                matchedFiles.add(filePath);
                                break; // 匹配到一个模式后不需要继续检查其他模式
                            }
                        }
                    }
                }
            }
        }
        return matchedFiles;
    }

    private boolean hasDataLines(SftpClient sftp, String filePath) throws IOException {
        try (InputStream in = sftp.read(filePath)) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            reader.readLine(); // 跳过表头
            String secondLine = reader.readLine();
            return secondLine != null && !secondLine.trim().isEmpty();
        }
    }

    private void downloadFile(SftpClient sftp, String remoteFilePath, String localFilePath) {
        try (InputStream inputStream = sftp.read(remoteFilePath)) {
            Files.copy(inputStream, FileSecUtils.getPath(localFilePath), StandardCopyOption.REPLACE_EXISTING);
            LOGGER.warn("Download succeeded. ");
        } catch (Exception e) {
            LOGGER.error("[OCDCollectionService][downloadFile]Exception while downloading from source file to target file ");
        }
    }

    private void uploadFile(SftpClient sftp, String localFilePath, String remoteFilePath) throws IOException {
        try (OutputStream outputStream = sftp.write(remoteFilePath)) {
            Files.copy(FileSecUtils.getPath(localFilePath), outputStream);
            LOGGER.warn("Uploaded succeeded. ");
        } catch (Exception e) {
            LOGGER.error("[OCDCollectionService][uploadFile]Exception occurred while uploading from local directory to target ");
        }
    }

    private void checkAndCreateDirectory(String directoryPath) {
        File file = UsFileUtils.getFile(directoryPath);
        if (!file.exists()) {
            if (!file.mkdir()) {
                LOGGER.error("[OCDCollectionService][checkAndCreateDirectory]create failed");
            }
        }
    }

    private boolean handleFileSync(List<String> srcDir, String destSrcDir, String destProDir) {
        int maxConcurrentDownloads = 3;
        int maxConcurrentUploads = 3;
        ExecutorService downloadExecutor = Executors.newFixedThreadPool(maxConcurrentDownloads);
        ExecutorService uploadExecutor = Executors.newFixedThreadPool(maxConcurrentUploads);
        try (SftpClient srcSftp = createSftpClient(remoteIp, username, password, port);
            SftpClient destSftp = createSftpClient(sftp_host, sftp_username, sftp_password, sftp_port)) {
            Set<String> srcFiles = retrieveSrcFiles(srcSftp, srcDir);
            // 对匹配上fileSet的源文件，统计大小并检验/opt/collection/srcTemp磁盘剩余空间  && 每个文件大小都要单独校验
            if (!checkFileAndFreeSpace(srcSftp, srcFiles, LOCALTEMPDIR, Constants.CHECK_FOR_SRC)) {
                LOGGER.error("[OCDCollectionService][handleFileSync] The remaining space on the host-{} is less than {} GB or file to download size exceeds {} GB, terminate the task.",
                        remoteIp, Constants.MIN_FREE_SPACE, Constants.MAX_FILE_SIZE);
                return false;
            }
            Set<String> destFiles = retrieveDestFiles(destSftp, destSrcDir, destProDir);
            Set<String> filesToUpdate = determineFilesToUpdate(destSftp, srcFiles, destFiles);
            // 对待推送的文件，统计大小并检验对端磁盘剩余空间 校验文件和磁盘剩余空间
            if (!checkFileAndFreeSpace(srcSftp, filesToUpdate, sftp_remoteDir, Constants.CHECK_FOR_DEST)) {
                LOGGER.error("[OCDCollectionService][handleFileSync] The remaining space on the host-{} is less than {} GB or file size to upload exceeds {} GB, terminate the task.",
                        remoteIp, Constants.MIN_FREE_SPACE, Constants.MAX_FILE_SIZE);
                return false;
            }
            Map<String, Future<?>> downloadTasks = new HashMap<>();
            Map<String, Future<?>> uploadTasks = new HashMap<>();

            for (String filePath : filesToUpdate) {
                String fileName = getFileName(filePath);
                String localFilePath = LOCALTEMPDIR + File.separator + fileName;
                String remoteFilePath = determineDestinationPath(fileName, destSrcDir, destProDir);

                Future<?> downloadTask = downloadExecutor.submit(() -> {
                    int maxRetries = 5;
                    int retryCount = 0;
                    while (retryCount < maxRetries) {
                        try (SftpClient srcSftpClient = createSftpClient(remoteIp, username, password, port)) {
                            downloadFile(srcSftpClient, filePath, localFilePath);
                            break;
                        } catch (Exception e) {
                            retryCount++;
                            if (retryCount < maxRetries) {
                                long retryInterval = getRetryInterval(retryCount);
                                LOGGER.warn("[OCDCollectionService][handleFileSync]Failed to download file. Retrying ({}/{}) in {} ms",
                                    retryCount, maxRetries, retryInterval);
                                try {
                                    Thread.sleep(retryInterval);
                                } catch (InterruptedException ex) {
                                    throw new RuntimeException(ex);
                                }
                            } else {
                                LOGGER.error("[OCDCollectionService][handleFileSync]Exception in download task: {}", e.getMessage());
                                throw new RuntimeException("[OCDCollectionService][handleFileSync]Failed to download file ");
                            }
                        }
                    }
                });

                downloadTasks.put(fileName, downloadTask);

                Future<?> uploadTask = uploadExecutor.submit(() -> {
                    int maxRetries = 5;
                    int retryCount = 0;
                    while (retryCount < maxRetries) {
                        try (SftpClient destSftpClient = createSftpClient(sftp_host, sftp_username, sftp_password, sftp_port)) {
                            downloadTask.get();
                            uploadFile(destSftpClient, localFilePath, remoteFilePath);
                            break;
                        } catch (Exception e) {
                            retryCount++;
                            if (retryCount < maxRetries) {
                                long retryInterval = getRetryInterval(retryCount);
                                LOGGER.warn("[OCDCollectionService][handleFileSync]Failed to upload file. Retrying ({}/{}) in {} ms",
                                    retryCount, maxRetries, retryInterval);
                                try {
                                    Thread.sleep(retryInterval);
                                } catch (InterruptedException ex) {
                                    throw new RuntimeException(ex);
                                }
                            } else {
                                LOGGER.error("[OCDCollectionService][handleFileSync]Exception in upload task: {}", e.getMessage());
                                throw new RuntimeException("[OCDCollectionService][handleFileSync]Failed to upload file");
                            }
                        }
                    }
                });
                uploadTasks.put(fileName, uploadTask);
            }
            waitForTasksCompletion(downloadTasks.values());
            waitForTasksCompletion(uploadTasks.values());
            return true;
        }  catch (IOException e) {
            LOGGER.error("[OCDCollectionService][handleFileSync]Error initializing file synchronization");
        }
        return false;
    }

    private long getRetryInterval(int retryCount) {
        // 使用指数退避算法计算重试间隔
        long baseInterval = 1000; // 基础间隔时间,单位为毫秒
        long maxInterval = 60000; // 最大间隔时间,单位为毫秒
        long interval = baseInterval * (long) Math.pow(2, retryCount - 1);
        return Math.min(interval, maxInterval);
    }

    private void waitForTasksCompletion(Collection<Future<?>> tasks) {
        for (Future<?> task : tasks) {
            try {
                task.get();
            } catch (InterruptedException | ExecutionException e) {
                LOGGER.error("[OCDCollectionService][waitForTasksCompletion]Exception while waiting for task completion: {}", e.getMessage());
            }
        }
    }


    private SftpClient createSftpClient(String ip, String username, String password, int port) {
        SftpClientUtil scu = new SftpClientUtil();
        return scu.SftpClient(ip, username, password, port);
    }
    private boolean checkFileAndFreeSpace(SftpClient sftpClient, Set<String> files, String destDir, int mod) {
        long totalFileSize = 0L;
        boolean fileSizeSatisfy = true;
        try {
            // 1. 校验sftp下每个文件大小，同时获取所有文件总大小  ---超40G的不下载，其他的正常下载？
            for (String file : files) {
                long fileSize = sftpClient.stat(file).getSize();
                if (!(fileSizeSatisfy &= checkSpecificFileSize(fileSize, Constants.MAX_FILE_SIZE, Constants.BYTE_SIZE_GB))) {
                    files.remove(file);
                    LOGGER.error("[checkFileAndFreeSpace]The file {} exceeds the size, remove from download list. : {}", file, Constants.MAX_FILE_SIZE * Constants.BYTE_SIZE_GB);
                } else {
                    totalFileSize += fileSize;
                }
            }
            // 2. 校验目录磁盘剩余空间
            if (mod == Constants.CHECK_FOR_SRC) {
                // 下载时校验本地目录
                return UsFileUtils.getFile(destDir).getFreeSpace() - totalFileSize > Constants.MIN_FREE_SPACE * Constants.BYTE_SIZE_GB;
            } else if (mod == Constants.CHECK_FOR_DEST) {
                // 上传时检验远程目录
                SftpClientUtil scu = new SftpClientUtil();
                try (ChannelExec execChannel = scu.getExecChannel(sftp_host, sftp_username,
                        sftp_password, sftp_port, "df -h " + destDir);
                     ByteArrayOutputStream outputErr = new ByteArrayOutputStream();
                     ByteArrayOutputStream output = new ByteArrayOutputStream()) {
                    execChannel.setOut(output);
                    execChannel.setErr(outputErr);
                    execChannel.open();
                    execChannel.waitFor(EnumSet.of(ClientChannelEvent.CLOSED), 0);
                    String commandResult = output.toString().replace("\n", " ");
                    Matcher matcher = Pattern.compile(".*(\\d+\\.?\\d+)G *(\\d+\\.?\\d+)G *(\\d+\\.?\\d+)G.*").matcher(commandResult);
                    double availSpace = 0.0d;
                    if (matcher.find()) {
                        availSpace = Double.parseDouble(matcher.group(3));
                        return availSpace * Constants.BYTE_SIZE_GB - totalFileSize > Constants.MIN_FREE_SPACE * Constants.BYTE_SIZE_GB;
                    } else {
                        LOGGER.error("not find free space of: {}:{}", sftp_host, destDir);
                        return false;
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.error("[OCDCollectionService][checkFileAndFreeSpace]occur error when check file and disk : {}", e.getMessage());
        }
        return false;
    }

    private boolean checkSpecificFileSize(long fileSize, long maxFileSize, long byteSizeGb) {
        return fileSize < maxFileSize * byteSizeGb;
    }

    public String getFileName(String filePath) {
        Path path = FileSecUtils.getPath(filePath);
        return path.getFileName().toString();
    }

    private String extractBaseFileName(String fileName) {
        int underscoreIndex = fileName.lastIndexOf("_");
        if (underscoreIndex != -1) {
            return fileName.substring(0, underscoreIndex);
        }
        return fileName;
    }

    private Set<String> determineFilesToUpdate(SftpClient destSftp, Set<String> srcFiles, Set<String> destFiles)
            throws IOException {
        Set<String> filesToUpdate = new HashSet<>();
        Map<String, String> destFilesMap = new HashMap<>();
        // 为目标文件创建映射，使用基本文件名作为键
        for (String destFile : destFiles) {
            String destFileName = FileSecUtils.getPath(destFile).getFileName().toString();
            String baseDestFileName = extractBaseFileName(destFileName);
            destFilesMap.put(baseDestFileName, destFile);
        }

        for (String srcFile : srcFiles) {
            String srcFileName = FileSecUtils.getPath(srcFile).getFileName().toString();
            String baseSrcFileName = extractBaseFileName(srcFileName);
            LocalDateTime srcFileTime = getFileTimestamp(srcFile);

            if (srcFileTime != null) {
                if (destFilesMap.containsKey(baseSrcFileName)) {
                    String destFilePath = destFilesMap.get(baseSrcFileName);
                    LocalDateTime destFileTime = getFileTimestamp(destFilePath);

                    if (destFileTime == null || srcFileTime.isAfter(destFileTime)) {
                        LOGGER.warn("[OCDCollectionService][determineFilesToUpdate]remove old file : {}", FileSecUtils.getPath(destFilePath));
                        destSftp.remove(FileSecUtils.getPath(destFilePath).toString());
                        filesToUpdate.add(srcFile);
                        if (processList.stream().anyMatch(srcFileName::contains)) {
                            downloadRemainingFiles(destSftp, destFilesMap);
                        }
                    }
                } else {
                    filesToUpdate.add(srcFile);
                }
            }
        }
        return filesToUpdate;
    }

    private void downloadRemainingFiles(SftpClient destSftp, Map<String, String> destFilesMap) {
        for (String key : destFilesMap.keySet()) {
            if (processList.stream().anyMatch(key::contains)) {
                String filePath = destFilesMap.get(key);
                String localPath = LOCALTEMPDIR + File.separator + FileSecUtils.getPath(filePath).getFileName();
                downloadFile(destSftp, filePath, localPath);
            }
        }
    }

    public LocalDateTime getFileTimestamp(String filePath) {
        Matcher matcher = CONTINUATIVE_NUM_PATTERN.matcher(filePath);
        if (matcher.find()) {
            String timestampStr = matcher.group(1); // 提取匹配的日期时间字符串
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
            try {
                return LocalDateTime.parse(timestampStr, formatter);
            } catch (Exception e) {
                LOGGER.error("[OCDCollectionService][getFileTimestamp]Error parsing date time from file name: " + filePath);
            }
        } else {
            LOGGER.error("[OCDCollectionService][getFileTimestamp]No valid timestamp found in file path: " + filePath);
        }
        return null;
    }

    /**
     * 确定目标路径
     *
     * @param fileName
     * @param destSrcDir
     * @param destProDir
     * @return
     */
    private String determineDestinationPath(String fileName, String destSrcDir, String destProDir) {
        for (String keyword : processList) {
            if (fileName.contains(keyword)) {
                return destSrcDir + File.separator + fileName;
            }
        }
        return destProDir + File.separator + fileName;
    }

    /**
     * 检索目标文件
     *
     * @param sftpClient
     * @param srcDir
     * @param proDir
     * @return
     */
    public Set<String> retrieveDestFiles(SftpClient sftpClient, String srcDir, String proDir) {
        Set<String> destFiles = new HashSet<>();
        try {
            // 检查并创建src目录
            ensureDirectoryExists(sftpClient, srcDir);
            // 读取 src 目录下的所有文件并添加到 destFiles 列表
            destFiles.addAll(listFiles(sftpClient, srcDir));

            // 检查并创建pro目录
            ensureDirectoryExists(sftpClient, proDir);
            // 读取 pro 目录下的所有文件添加到同一个列表
            destFiles.addAll(listFiles(sftpClient, proDir));
        } catch (IOException e) {
            LOGGER.error("[OCDCollectionService][retrieveDestFiles]Error while retrieving files from src and pro directories");
        }
        return destFiles;
    }

    private void ensureDirectoryExists(SftpClient sftpClient, String directory) throws IOException {
        try {
            sftpClient.stat(directory);
        } catch (SftpException e) {
            if (e.getStatus() == SftpConstants.SSH_FX_NO_SUCH_FILE) {
                // 目录不存在，尝试创建
                sftpClient.mkdir(directory);
                LOGGER.warn("[OCDCollectionService][ensureDirectoryExists]Directory created: {}", directory);
            }
        }
    }

    private List<String> listFiles(SftpClient sftpClient, String directory) throws IOException {
        List<String> fileList = new ArrayList<>();
        Iterable<SftpClient.DirEntry> dirEntries = sftpClient.readDir(directory);
        for (SftpClient.DirEntry entry : dirEntries) {
            if (!entry.getAttributes().isDirectory()) { // 过滤掉子目录，只添加文件
                String absolttePath = directory + File.separator + entry.getFilename();
                fileList.add(absolttePath);
            }
        }
        return fileList;
    }

    // 清空本地临时目录中的所有文件
    private void clearLocalTempDir() {
        Path tempDir = FileSecUtils.getPath(LOCALTEMPDIR);
        if (!Files.exists(tempDir)) {
            LOGGER.warn("[OCDCollectionService][clearLocalTempDir]Local temp directory does not exist: {}", LOCALTEMPDIR);
            return;
        }
        LOGGER.warn("[OCDCollectionService][clearLocalTempDir]Starting to clear the temporary directory.");
        try (Stream<Path> paths = Files.list(tempDir)) {
            paths.filter(Files::isRegularFile).forEach(path -> {
                try {
                    Files.delete(path);
                } catch (IOException e) {
                    LOGGER.error("[OCDCollectionService][clearLocalTempDir]Failed to delete file: {}", path);
                }
            });
            LOGGER.warn("Cleared successfully.");
        } catch (IOException e) {
            LOGGER.error("[OCDCollectionService][clearLocalTempDir]Error while clearing local temp directory: {}", LOCALTEMPDIR);
        }
    }
}
