
/**
 * 同步文件上传下载
 *
 * @since 2024/5/2
 */
@Component
public class FileSynchronizationServiceImpl implements FileSynchronizationService {
    private static final Logger LOGGER = LoggerFactory.getLogger(FileSynchronizationServiceImpl.class);

    private static String remoteIp;

    private static String remoteDir;

    private static int port;

    private static String username;

    private static String password;

    private static Set<String> fileSet;

    private static String filesDirectory;

    private static Pattern dirPattern;

    private static int maxDirSize;

    private static String sftp_host;

    private static int sftp_port;

    private static String sftp_username;

    private static String sftp_password;

    private static String sftp_remoteDir;

    private static String src_remote_dir;

    private static String col_remote_dir;

    private static String pro_remote_dir;

    private static final String LOCALTEMPDIR = "/opt/collection/srcTemp";



    private static final List<String> processList = Arrays.asList("_SEGMENT_", "_STRONGHOLD_", "_CABLELAYING_",
        "_CIRCUITASSIGN_", "_CIRCUITLINK_", "_FIBER_", "_JOINT_", "_LOGICALFIBERCIR_", "_OCCP_", "_OPTCABLESECTION_",
        "_OPTICALCABLE_", "_OPTICALCIRCUIT_", "_IRM_IV_OTN_");

    public static void fetchConfigFromPage() {
        Map<String, String> parameter = ServiceUtil.getNebulaConfig();
        remoteIp = parameter.get("remoteIp");
        remoteDir = parameter.get("remoteDir");
        port = Integer.parseInt(parameter.get("port"));
        username = parameter.get("username");
        password = parameter.get("password");
        fileSet = new HashSet<>(Arrays.asList(parameter.get("fileSet").split(",")));
        filesDirectory = parameter.get("filesDirectory");
        maxDirSize = Integer.parseInt(parameter.get("maxDirSize"));
        dirPattern = Pattern.compile(parameter.get("directoryPattern"));
        sftp_host = parameter.get("sftp.host");
        sftp_port = Integer.parseInt(parameter.get("sftp.port"));
        sftp_username = parameter.get("sftp.username");
        sftp_password = parameter.get("sftp.password");
        sftp_remoteDir = parameter.get("sftp.remoteDir");
        src_remote_dir = sftp_remoteDir + File.separator + "src";
        col_remote_dir = sftp_remoteDir + File.separator + "col";
        pro_remote_dir = sftp_remoteDir + File.separator + "pro";
    }

    @Override
    public void synchronizeFiles() throws IOException {
        checkAndCreateDirectory(LOCALTEMPDIR);
        SftpClient srcSftpClient = SftpClientUtil.SftpClient(remoteIp, username, password, port);
        SftpClient destSftpClient = SftpClientUtil.SftpClient(sftp_host, sftp_username, sftp_password, sftp_port);
        List<String> recentDirs = getRecentDirs(srcSftpClient, remoteDir, maxDirSize);
        handleFileSync(srcSftpClient, destSftpClient, recentDirs, src_remote_dir, pro_remote_dir);
    }

    private List<String> getRecentDirs(SftpClient sftp, String remoteDir, int maxDirSize) throws IOException {
        Iterable<SftpClient.DirEntry> dirEntries = sftp.readDir(remoteDir);
        List<String> recentDirs = new ArrayList<>();
        for (SftpClient.DirEntry entry : dirEntries) {
            if (entry.getAttributes().isDirectory()) {
                String dirName = entry.getFilename();
                if (dirPattern.matcher(dirName).matches()) {
                    try {
                        sftp.stat(remoteDir + File.separator + dirName + File.separator + filesDirectory);
                        recentDirs.add(dirName);
                    } catch (SftpException e) {
                        LOGGER.error("Skipping directory as 'files' subdirectory does not exist: " + dirName);
                        continue;
                    }
                }
            }
        }
        recentDirs.sort(Collections.reverseOrder());
        return recentDirs.subList(0, Math.min(recentDirs.size(), maxDirSize));
    }

    private Set<String> retrieveSrcFiles(SftpClient sftp, List<String> recentDirs) throws IOException {
        Set<String> matchedFiles = new HashSet<>();
        for (String dir : recentDirs) {
            Iterable<SftpClient.DirEntry> files = sftp.readDir(
                remoteDir + File.separator + dir + File.separator + filesDirectory);
            for (SftpClient.DirEntry entry : files) {
                String filename = entry.getFilename();
                for (String pattern : fileSet) {
                    if (filename.contains(pattern)) {
                        String filePath = remoteDir + File.separator + dir + File.separator + filesDirectory
                            + File.separator + filename;
                        SftpClient.Attributes attrs = sftp.stat(filePath);
                        if (attrs.getSize() > 0) {
                            if (hasDataLines(sftp, filePath)) {
                                matchedFiles.add(filePath);
                                break; // 匹配到一个模式后不需要继续检查其他模式
                            }
                        }
                    }
                }
            }
        }
        return matchedFiles;
    }

    private boolean hasDataLines(SftpClient sftp, String filePath) throws IOException {
        try (InputStream in = sftp.read(filePath)) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            reader.readLine(); // 跳过表头
            String secondLine = reader.readLine();
            return secondLine != null && !secondLine.trim().isEmpty();
        }
    }

    private void deleteOldFiles(File[] localFiles) {
        for (File localFile : localFiles) {
            LOGGER.warn("Deleting old file: {}", localFile.getAbsolutePath());
            localFile.delete();
        }
    }

    private void downloadFile(SftpClient sftp, String remoteFilePath, String localFilePath) {
        try {
            try (InputStream inputStream = sftp.read(remoteFilePath)) {
                Files.copy(inputStream, Paths.get(localFilePath), StandardCopyOption.REPLACE_EXISTING);
                LOGGER.warn("Download succeeded. ");
            }
        } catch (IOException e) {
            LOGGER.error("an exception occurs when downloading from the source file to the destination file");
        }
    }

    private void uploadFile(SftpClient sftp, String localFilePath, String remoteFilePath) throws IOException {
        try (OutputStream outputStream = sftp.write(remoteFilePath)) {
            Files.copy(Paths.get(localFilePath), outputStream);
            LOGGER.warn("Uploaded succeeded. ");
        }
    }
    private void checkAndCreateDirectory(String directoryPath) {
        Path path = Paths.get(directoryPath);
        if (!Files.exists(path)) {
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    private void handleFileSync(SftpClient srcSftp, SftpClient destSftp, List<String> srcDir, String destSrcDir, String destProDir) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        try {
            Set<String> srcFiles = retrieveSrcFiles(srcSftp, srcDir);
            Set<String> destFiles = retrieveDestFiles(destSftp, destSrcDir, destProDir);
            Set<String> filesToUpdate = determineFilesToUpdate(destSftp, srcFiles, destFiles);
            if (executor.isShutdown()) {
                LOGGER.error("Executor service is already shutdown");
                return;
            }
            for (String filePath : filesToUpdate) {
                String fileName = getFileName(filePath);

                LOGGER.warn("Submitting task for file :{}",filePath);
                executor.submit(() -> {
                    try {
                        String localFilePath = LOCALTEMPDIR + File.separator + fileName;
                        String remoteFilePath = determineDestinationPath(fileName, destSrcDir, destProDir);

                        // 下载文件
                        downloadFile(srcSftp, filePath, localFilePath);
                        LOGGER.warn("Downloaded file: {}", filePath);

                        // 上传文件
                        uploadFile(destSftp, localFilePath, remoteFilePath);
                        LOGGER.warn("Uploaded file to {}: {}", remoteFilePath, filePath);
                    } catch (Exception e) {
                        LOGGER.error("Exception in task: {}", e.getMessage(), e);
                    }
                });
            }

            // 等待所有任务完成
            executor.shutdown();
            if(executor.awaitTermination(1, TimeUnit.HOURS)){  // 根据实际情况调整超时时间
                LOGGER.warn("Executor did not terminate in the specified time");
            }
        } catch (InterruptedException e) {
            LOGGER.error("Thread interrupted during file synchronization", e);
            Thread.currentThread().interrupt();
        } catch (IOException e) {
            LOGGER.error("Error initializing file synchronization", e);
        }
    }

    public String getFileName(String filePath) {
        Path path = Paths.get(filePath);
        return path.getFileName().toString();
    }

    // private Set<String> determineFilesToUpdate(String destDir, Set<String> srcFiles, Set<String> destFiles)
    //     throws IOException {
    //
    //     Set<String> filesToUpdate = new HashSet<>();
    //     for (String srcFileName : srcFiles) {
    //         String srcFilePath = srcFileName; // 构造完整的源文件路径
    //         LocalDateTime srcFileTime = getFileTimestamp(srcFilePath);
    //         if (srcFileTime != null && destFiles.contains(srcFileName)) {
    //             String destFilePath = destDir + File.separator + srcFileName;
    //             LocalDateTime destFileTime = getFileTimestamp(destFilePath);
    //             // 检查时间戳，并只有在源时间戳较新时添加到更新列表
    //             if (destFileTime != null && srcFileTime.isAfter(destFileTime)) {
    //                 filesToUpdate.add(srcFileName);
    //             }
    //         }
    //         // 如果目标文件中不存在源文件，也添加到更新列表
    //         if (!destFiles.contains(srcFileName)) {
    //             filesToUpdate.add(srcFileName);
    //         }
    //     }
    //     return filesToUpdate;
    // }
    private String extractBaseFileName(String fileName) {
        // 假设时间戳总是在最后，前有一个下划线分隔，并且时间戳为14位数字
        int underscoreIndex = fileName.lastIndexOf("_");
        if (underscoreIndex != -1) {
            return fileName.substring(0, underscoreIndex);
        }
        return fileName; // 如果没有下划线，返回原文件名（兜底方案）
    }
    private Set<String> determineFilesToUpdate(SftpClient destSftp, Set<String> srcFiles, Set<String> destFiles) throws IOException {
        Set<String> filesToUpdate = new HashSet<>();
        Map<String, String> destFilesMap = new HashMap<>();

        // 为目标文件创建映射，使用基本文件名作为键
        for (String destFile : destFiles) {
            String destFileName = Paths.get(destFile).getFileName().toString();
            String baseDestFileName = extractBaseFileName(destFileName);
            destFilesMap.put(baseDestFileName, destFile);
        }

        for (String srcFile : srcFiles) {
            String srcFileName = Paths.get(srcFile).getFileName().toString();
            String baseSrcFileName = extractBaseFileName(srcFileName);
            LocalDateTime srcFileTime = getFileTimestamp(srcFile);

            if (srcFileTime != null) {
                if (destFilesMap.containsKey(baseSrcFileName)) {
                    String destFilePath = destFilesMap.get(baseSrcFileName);
                    LocalDateTime destFileTime = getFileTimestamp(destFilePath);

                    if (destFileTime == null || srcFileTime.isAfter(destFileTime)) {
                        LOGGER.warn("remove old file : {}",Paths.get(destFilePath));
                        destSftp.remove(Paths.get(destFilePath).toString());
                        filesToUpdate.add(srcFile);
                    }
                } else {
                    filesToUpdate.add(srcFile);
                }
            }
        }
        return filesToUpdate;
    }
    public LocalDateTime getFileTimestamp(String filePath) {
        Pattern pattern = Pattern.compile("(\\d{14})"); // 匹配连续的14位数字
        Matcher matcher = pattern.matcher(filePath);

        if (matcher.find()) {
            String timestampStr = matcher.group(1); // 提取匹配的日期时间字符串
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
            try {
                return LocalDateTime.parse(timestampStr, formatter);
            } catch (Exception e) {
                System.err.println("Error parsing date time from file name: " + filePath);
                e.printStackTrace();
            }
        } else {
            System.err.println("No valid timestamp found in file path: " + filePath);
        }
        return null;
    }


    /**
     * 确定目标路径
     * @param fileName
     * @param destSrcDir
     * @param destProDir
     * @return
     */
    private String determineDestinationPath(String fileName, String destSrcDir, String destProDir) {
        for (String keyword : processList) {
            if (fileName.contains(keyword)) {
                return destSrcDir + File.separator + fileName;
            }
        }
        return destProDir + File.separator + fileName;
    }

    /**
     * 检索目标文件
     * @param sftpClient
     * @param srcDir
     * @param proDir
     * @return
     */
    public Set<String> retrieveDestFiles(SftpClient sftpClient, String srcDir, String proDir) {
        Set<String> destFiles = new HashSet<>();
        try {
            // 检查并创建src目录
            ensureDirectoryExists(sftpClient, srcDir);
            // 读取 src 目录下的所有文件并添加到 destFiles 列表
            destFiles.addAll(listFiles(sftpClient, srcDir));

            // 检查并创建pro目录
            ensureDirectoryExists(sftpClient, proDir);
            // 读取 pro 目录下的所有文件添加到同一个列表
            destFiles.addAll(listFiles(sftpClient, proDir));
        } catch (IOException e) {
            LOGGER.error("Error while retrieving files from src and pro directories", e);
        }
        return destFiles;
    }

    private void ensureDirectoryExists(SftpClient sftpClient, String directory) throws IOException {
        try {
            sftpClient.stat(directory);
        } catch (SftpException e) {
            if (e.getStatus() == SftpConstants.SSH_FX_NO_SUCH_FILE) {
                // 目录不存在，尝试创建
                sftpClient.mkdir(directory);
                LOGGER.warn("Directory created: {}", directory);
            } else {
                // 抛出其他异常
                throw e;
            }
        }
    }

    private List<String> listFiles(SftpClient sftpClient, String directory) throws IOException {
        List<String> fileList = new ArrayList<>();
        Iterable<SftpClient.DirEntry> dirEntries = sftpClient.readDir(directory);
        for (SftpClient.DirEntry entry : dirEntries) {
            if (!entry.getAttributes().isDirectory()) { // 过滤掉子目录，只添加文件
                String absolttePath = directory + File.separator +entry.getFilename();
                fileList.add(absolttePath);
            }
        }
        return fileList;
    }


}
