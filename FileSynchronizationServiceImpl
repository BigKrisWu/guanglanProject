import com.huawei.baize.security.misc.io.FileSecUtils;
import com.huawei.fiber.constant.CodeStatus;
import com.huawei.fiber.service.FileSynchronizationService;
import com.huawei.fiber.utils.ServiceUtil;
import com.huawei.fiber.utils.SftpClientUtil;

import com.alibaba.fastjson.JSONObject;

import org.apache.sshd.sftp.client.SftpClient;
import org.apache.sshd.sftp.common.SftpConstants;
import org.apache.sshd.sftp.common.SftpException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * 同步文件上传下载
 *
 * @since 2024/5/2
 */
@Component
public class FileSynchronizationServiceImpl implements FileSynchronizationService {
    private static final Logger LOGGER = LoggerFactory.getLogger(FileSynchronizationServiceImpl.class);

    private static String remoteIp;

    private static String remoteDir;

    private static int port;

    private static String username;

    private static String password;

    private static Set<String> fileSet;

    private static String filesDirectory;

    private static int maxDirSize;

    private static String sftp_host;

    private static int sftp_port;

    private static String sftp_username;

    private static String sftp_password;

    private static String sftp_remoteDir;

    public static final String LOCALTEMPDIR = "/opt/collection/srcTemp";

    public static final Pattern DIR_PATTERN = Pattern.compile("\\d{8}");
    public static final Pattern CONTINUATIVE_NUM_PATTERN = Pattern.compile("(\\d{14})"); // 匹配连续的14位数字

    public static Map<String, String> map = new HashMap<>(3);

    private static final List<String> processList = Arrays.asList("_SEGMENT_", "_STRONGHOLD_", "_CABLELAYING_",
        "_CIRCUITASSIGN_", "_CIRCUITLINK_", "_FIBER_", "_JOINT_", "_LOGICALFIBERCIR_", "_OCCP_", "_OPTCABLESECTION_",
        "_OPTICALCABLE_", "_OPTICALCIRCUIT_", "_IRM_IV_OTN_");

    public static void fetchConfigFromPage() {
        Map<String, String> parameter = ServiceUtil.getNebulaConfig();
        remoteIp = parameter.get("remoteIp");
        remoteDir = parameter.get("remoteDir");
        port = Integer.parseInt(parameter.get("port"));
        username = parameter.get("username");
        password = parameter.get("password");
        fileSet = new HashSet<>(Arrays.asList(parameter.get("fileSet").split(",")));
        filesDirectory = parameter.get("filesDirectory");
        maxDirSize = Integer.parseInt(parameter.get("maxDirSize"));
        sftp_host = parameter.get("sftp.host");
        sftp_port = Integer.parseInt(parameter.get("sftp.port"));
        sftp_username = parameter.get("sftp.username");
        sftp_password = parameter.get("sftp.password");
        sftp_remoteDir = parameter.get("sftp.remoteDir");
        map.put("src", sftp_remoteDir + File.separator + "src");
        map.put("col", sftp_remoteDir + File.separator + "col");
        map.put("pro", sftp_remoteDir + File.separator + "pro");
    }

    @Override
    public void synchronizeFiles() throws IOException {
        checkAndCreateDirectory(LOCALTEMPDIR);
        SftpClient srcSftpClient = SftpClientUtil.SftpClient(remoteIp, username, password, port);
        SftpClient destSftpClient = SftpClientUtil.SftpClient(sftp_host, sftp_username, sftp_password, sftp_port);
        List<String> recentDirs = getRecentDirs(srcSftpClient, remoteDir, maxDirSize);
        handleFileSync(srcSftpClient, destSftpClient, recentDirs, map.get("src"), map.get("pro"));
    }

    @Override
    public JSONObject uploadResultFiles(String localDirectoryPath, String remoteDirectoryPath) throws IOException {
        JSONObject result = new JSONObject();
        SftpClient sftpClient = SftpClientUtil.SftpClient(sftp_host, sftp_username, sftp_password, sftp_port);
        ensureDirectoryExists(sftpClient, remoteDirectoryPath);

        try (Stream<Path> paths = Files.walk(FileSecUtils.getPath(localDirectoryPath))) {
            List<Path> filesToUpload = paths.filter(Files::isRegularFile)
                .filter(path -> path.getFileName().toString().startsWith("D_RNT_IRM_IV"))
                .collect(Collectors.toList());

            // 上传每个文件到远程目录
            for (Path file : filesToUpload) {
                String localFilePath = file.toString();
                String remoteFilePath = remoteDirectoryPath + File.separator + file.getFileName().toString();
                uploadFile(sftpClient, localFilePath, remoteFilePath);
            }
            clearLocalTempDir();
            result.put(CodeStatus.SUCCESS.getValue(), "The task is executed successfully.");
        } catch (IOException e) {
            result.put(CodeStatus.FAILED.getValue(), "The task is executed failed.");
            LOGGER.error("[OCDCollectionService][uploadResultFiles]Error uploading files: {}", e.getMessage());
        } finally {
            SftpClientUtil.closeSftpClient(sftpClient);
        }
        return result;
    }

    private List<String> getRecentDirs(SftpClient sftp, String remoteDir, int maxDirSize) throws IOException {
        Iterable<SftpClient.DirEntry> dirEntries = sftp.readDir(remoteDir);
        List<String> recentDirs = new ArrayList<>();
        for (SftpClient.DirEntry entry : dirEntries) {
            if (entry.getAttributes().isDirectory()) {
                String dirName = entry.getFilename();
                if (DIR_PATTERN.matcher(dirName).matches()) {
                    try {
                        sftp.stat(remoteDir + File.separator + dirName + File.separator + filesDirectory);
                        recentDirs.add(dirName);
                    } catch (SftpException e) {
                        LOGGER.error("[OCDCollectionService][getRecentDirs]Skipping directory as 'files' subdirectory does not exist: " + dirName);
                        continue;
                    }
                }
            }
        }
        recentDirs.sort(Collections.reverseOrder());
        return recentDirs.subList(0, Math.min(recentDirs.size(), maxDirSize));
    }

    private Set<String> retrieveSrcFiles(SftpClient sftp, List<String> recentDirs) throws IOException {
        Set<String> matchedFiles = new HashSet<>();
        for (String dir : recentDirs) {
            Iterable<SftpClient.DirEntry> files = sftp.readDir(
                remoteDir + File.separator + dir + File.separator + filesDirectory);
            for (SftpClient.DirEntry entry : files) {
                String filename = entry.getFilename();
                for (String pattern : fileSet) {
                    if (filename.contains(pattern)) {
                        String filePath = remoteDir + File.separator + dir + File.separator + filesDirectory
                            + File.separator + filename;
                        SftpClient.Attributes attrs = sftp.stat(filePath);
                        if (attrs.getSize() > 0) {
                            if (hasDataLines(sftp, filePath)) {
                                matchedFiles.add(filePath);
                                break; // 匹配到一个模式后不需要继续检查其他模式
                            }
                        }
                    }
                }
            }
        }
        return matchedFiles;
    }

    private boolean hasDataLines(SftpClient sftp, String filePath) throws IOException {
        try (InputStream in = sftp.read(filePath)) {
            BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            reader.readLine(); // 跳过表头
            String secondLine = reader.readLine();
            return secondLine != null && !secondLine.trim().isEmpty();
        }
    }

    private void downloadFile(SftpClient sftp, String remoteFilePath, String localFilePath) {
        try (InputStream inputStream = sftp.read(remoteFilePath)) {
            Files.copy(inputStream, FileSecUtils.getPath(localFilePath), StandardCopyOption.REPLACE_EXISTING);
            LOGGER.warn("Download succeeded. ");
        } catch (Exception e) {
            e.printStackTrace();
            LOGGER.error("[OCDCollectionService][downloadFile]Exception while downloading from source file to target file ");
        }
    }

    private void uploadFile(SftpClient sftp, String localFilePath, String remoteFilePath) throws IOException {
        try (OutputStream outputStream = sftp.write(remoteFilePath)) {
            Files.copy(FileSecUtils.getPath(localFilePath), outputStream);
            LOGGER.warn("Uploaded succeeded. ");
        } catch (Exception e) {
            e.printStackTrace();
            LOGGER.error("[OCDCollectionService][uploadFile]Exception occurred while uploading from local directory to target ");
        }
    }

    private void checkAndCreateDirectory(String directoryPath) {
        Path path = FileSecUtils.getPath(directoryPath);
        if (!Files.exists(path)) {
            try {
                Files.createDirectories(path);
            } catch (IOException e) {
                LOGGER.error("[OCDCollectionService][checkAndCreateDirectory]create failed");
            }
        }
    }

    private void handleFileSync(SftpClient srcSftp, SftpClient destSftp, List<String> srcDir, String destSrcDir, String destProDir) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        try {
            Set<String> srcFiles = retrieveSrcFiles(srcSftp, srcDir);
            Set<String> destFiles = retrieveDestFiles(destSftp, destSrcDir, destProDir);
            Set<String> filesToUpdate = determineFilesToUpdate(destSftp, srcFiles, destFiles);
            if (executor.isShutdown()) {
                LOGGER.error("[OCDCollectionService][handleFileSync]Executor service is already shutdown");
                return;
            }
            for (String filePath : filesToUpdate) {
                String fileName = getFileName(filePath);

                executor.submit(() -> {
                    try {
                        String localFilePath = LOCALTEMPDIR + File.separator + fileName;
                        String remoteFilePath = determineDestinationPath(fileName, destSrcDir, destProDir);

                        // 下载文件
                        downloadFile(srcSftp, filePath, localFilePath);
                        LOGGER.warn("Downloaded file: {}", filePath);

                        // 上传文件
                        uploadFile(destSftp, localFilePath, remoteFilePath);
                        LOGGER.warn("Uploaded file to {}: {}", remoteFilePath, filePath);
                    } catch (Exception e) {
                        LOGGER.error("[OCDCollectionService][handleFileSync]Exception in task: {}", e.getMessage());
                    }
                });
            }

            // 等待所有任务完成
            executor.shutdown();
            if (executor.awaitTermination(1, TimeUnit.DAYS)) {  // 根据实际情况调整超时时间
                LOGGER.warn("[OCDCollectionService][handleFileSync]Executor did not terminate in the specified time");
            }
        } catch (InterruptedException e) {
            LOGGER.error("[OCDCollectionService][handleFileSync]Thread interrupted during file synchronization");
            Thread.currentThread().interrupt();
        } catch (IOException e) {
            LOGGER.error("[OCDCollectionService][handleFileSync]Error initializing file synchronization");
        } finally {
            SftpClientUtil.closeSftpClient(srcSftp);
            SftpClientUtil.closeSftpClient(destSftp);
        }
    }

    public String getFileName(String filePath) {
        Path path = FileSecUtils.getPath(filePath);
        return path.getFileName().toString();
    }

    private String extractBaseFileName(String fileName) {
        int underscoreIndex = fileName.lastIndexOf("_");
        if (underscoreIndex != -1) {
            return fileName.substring(0, underscoreIndex);
        }
        return fileName;
    }

    private Set<String> determineFilesToUpdate(SftpClient destSftp, Set<String> srcFiles, Set<String> destFiles)
        throws IOException {
        Set<String> filesToUpdate = new HashSet<>();
        Map<String, String> destFilesMap = new HashMap<>();
        // 为目标文件创建映射，使用基本文件名作为键
        for (String destFile : destFiles) {
            String destFileName = FileSecUtils.getPath(destFile).getFileName().toString();
            String baseDestFileName = extractBaseFileName(destFileName);
            destFilesMap.put(baseDestFileName, destFile);
        }

        for (String srcFile : srcFiles) {
            String srcFileName = FileSecUtils.getPath(srcFile).getFileName().toString();
            String baseSrcFileName = extractBaseFileName(srcFileName);
            LocalDateTime srcFileTime = getFileTimestamp(srcFile);

            if (srcFileTime != null) {
                if (destFilesMap.containsKey(baseSrcFileName)) {
                    String destFilePath = destFilesMap.get(baseSrcFileName);
                    LocalDateTime destFileTime = getFileTimestamp(destFilePath);

                    if (destFileTime == null || srcFileTime.isAfter(destFileTime)) {
                        LOGGER.warn("[OCDCollectionService][determineFilesToUpdate]remove old file : {}", FileSecUtils.getPath(destFilePath));
                        destSftp.remove(FileSecUtils.getPath(destFilePath).toString());
                        filesToUpdate.add(srcFile);
                        if(processList.stream().anyMatch(srcFileName::contains)){
                            downloadRemainingFiles(destSftp,destFilesMap);
                        }
                    }
                } else {
                    filesToUpdate.add(srcFile);
                }
            }
        }
        return filesToUpdate;
    }
    private void downloadRemainingFiles(SftpClient destSftp, Map<String, String> destFilesMap) {
        for (String key : destFilesMap.keySet()) {
            if (processList.stream().anyMatch(key::contains)) {
                String filePath = destFilesMap.get(key);
                String localPath = LOCALTEMPDIR + File.separator + FileSecUtils.getPath(filePath).getFileName();
                downloadFile(destSftp, filePath, localPath);
            }
        }
    }

    public LocalDateTime getFileTimestamp(String filePath) {
        Matcher matcher = CONTINUATIVE_NUM_PATTERN.matcher(filePath);
        if (matcher.find()) {
            String timestampStr = matcher.group(1); // 提取匹配的日期时间字符串
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
            try {
                return LocalDateTime.parse(timestampStr, formatter);
            } catch (Exception e) {
                LOGGER.error("[OCDCollectionService][getFileTimestamp]Error parsing date time from file name: " + filePath);
            }
        } else {
            LOGGER.error("[OCDCollectionService][getFileTimestamp]No valid timestamp found in file path: " + filePath);
        }
        return null;
    }

    /**
     * 确定目标路径
     * @param fileName
     * @param destSrcDir
     * @param destProDir
     * @return
     */
    private String determineDestinationPath(String fileName, String destSrcDir, String destProDir) {
        for (String keyword : processList) {
            if (fileName.contains(keyword)) {
                return destSrcDir + File.separator + fileName;
            }
        }
        return destProDir + File.separator + fileName;
    }

    /**
     * 检索目标文件
     * @param sftpClient
     * @param srcDir
     * @param proDir
     * @return
     */
    public Set<String> retrieveDestFiles(SftpClient sftpClient, String srcDir, String proDir) {
        Set<String> destFiles = new HashSet<>();
        try {
            // 检查并创建src目录
            ensureDirectoryExists(sftpClient, srcDir);
            // 读取 src 目录下的所有文件并添加到 destFiles 列表
            destFiles.addAll(listFiles(sftpClient, srcDir));

            // 检查并创建pro目录
            ensureDirectoryExists(sftpClient, proDir);
            // 读取 pro 目录下的所有文件添加到同一个列表
            destFiles.addAll(listFiles(sftpClient, proDir));
        } catch (IOException e) {
            LOGGER.error("[OCDCollectionService][retrieveDestFiles]Error while retrieving files from src and pro directories");
        }
        return destFiles;
    }

    private void ensureDirectoryExists(SftpClient sftpClient, String directory) throws IOException {
        try {
            sftpClient.stat(directory);
        } catch (SftpException e) {
            if (e.getStatus() == SftpConstants.SSH_FX_NO_SUCH_FILE) {
                // 目录不存在，尝试创建
                sftpClient.mkdir(directory);
                LOGGER.warn("[OCDCollectionService][ensureDirectoryExists]Directory created: {}", directory);
            }
        }
    }

    private List<String> listFiles(SftpClient sftpClient, String directory) throws IOException {
        List<String> fileList = new ArrayList<>();
        Iterable<SftpClient.DirEntry> dirEntries = sftpClient.readDir(directory);
        for (SftpClient.DirEntry entry : dirEntries) {
            if (!entry.getAttributes().isDirectory()) { // 过滤掉子目录，只添加文件
                String absolttePath = directory + File.separator + entry.getFilename();
                fileList.add(absolttePath);
            }
        }
        return fileList;
    }

    // 清空本地临时目录中的所有文件
    private void clearLocalTempDir() {
        Path tempDir = FileSecUtils.getPath(LOCALTEMPDIR);
        if (!Files.exists(tempDir)) {
            LOGGER.warn("[OCDCollectionService][clearLocalTempDir]Local temp directory does not exist: {}", LOCALTEMPDIR);
            return;
        }
        LOGGER.warn("[OCDCollectionService][clearLocalTempDir]Starting to clear the temporary directory.");
        try (Stream<Path> paths = Files.list(tempDir)) {
            paths.filter(Files::isRegularFile).forEach(path -> {
                try {
                    Files.delete(path);
                } catch (IOException e) {
                    LOGGER.error("[OCDCollectionService][clearLocalTempDir]Failed to delete file: {}", path);
                }
            });
            LOGGER.warn("Cleared successfully.");
        } catch (IOException e) {
            LOGGER.error("[OCDCollectionService][clearLocalTempDir]Error while clearing local temp directory: {}", LOCALTEMPDIR);
        }
    }
}
